## অ্যারে (Array): "একই জাতের মেলা"
অ্যারে হলো এমন একটি লিস্ট যেখানে আপনি একই ধরনের অনেকগুলো ডাটা রাখতে পারেন। এর কোনো নির্দিষ্ট লিমিট নেই—আপনি যত খুশি ডাটা যোগ করতে পারেন।

```bash
let friends: string[] = ["Sakib", "Rakib", "Tamim"];
// অথবা
let salary: Array<number> = [25000, 30000, 45000];
```

## টাপল (Tuple): "ফিক্সড বা নির্দিষ্ট সেট"
এটিই হলো টাইপস্ক্রিপ্টের স্পেশাল ফিচার। টাপল হলো এমন এক ধরনের অ্যারে যেখানে:

1. ডাটা সংখ্যা ফিক্সড (কয়টা এলিমেন্ট থাকবে তা আগে থেকেই বলা থাকে)।
2. প্রতিটি পজিশনে কোন ধরনের ডাটা থাকবে তা নির্দিষ্ট।

```bash
let person: [number, string, boolean];

person = [1, "Anis", true]; // একদম সঠিক
// person = ["Anis", 1, true]; // ভুল! কারণ প্রথমে নাম্বার থাকার কথা ছিল।
```


**টাপল হলো আপনার মানিব্যাগের মতো। ধরুন আপনার মানিব্যাগে ৩টি পকেট আছে: প্রথম পকেটে শুধু 'টাকা' (Number), দ্বিতীয় পকেটে 'আইডি কার্ড' (String), আর তৃতীয় পকেটে 'বাসের টিকিট' (Boolean) থাকবে। আপনি চাইলে হুট করে পকেট বাড়াতে পারবেন না, আর এক পকেটের জিনিস অন্য পকেটে রাখতে পারবেন না।**

## ইন-ডেপথ মেকানিজম: কেন টাপল ব্যবহার করবেন?

একজন স্টাফ ইঞ্জিনিয়ার হিসেবে আমি তখনই টাপল ব্যবহার করি যখন আমি নিশ্চিত যে ডাটার স্ট্রাকচার বদলাবে না।

উদাহরণ: HTTP Status Code আপনি একটি API রেসপন্স পাঠাচ্ছেন যেখানে প্রথমটা হবে স্ট্যাটাস কোড (Number) আর দ্বিতীয়টা হবে মেসেজ (String)।

```bash
type Response = [number, string];

const success: Response = [200, "Success"];
const notFound: Response = [404, "Not Found"];
```

এখানে যদি ভুল করে কেউ ["Success", 200] লিখে ফেলে, তবে টাইপস্ক্রিপ্ট কম্পাইল করার আগেই এরর দেবে। জাভাস্ক্রিপ্টে এই ভুলটা ধরা খুব কঠিন হতো।

## একটি "বিপজ্জনক" বিষয় (Interview Secret)
টাপলের একটি সীমাবদ্ধতা আছে যা অনেক সিনিয়র ডেভেলপারও ভুল করেন। যদিও আমরা বলি টাপল "ফিক্সড", কিন্তু আপনি যদি .push() মেথড ব্যবহার করেন, তবে টাপলে নতুন ডাটা ঢুকে যায়!

```bash
let myTuple: [number, string] = [1, "Hello"];
myTuple.push(100); // টাইপস্ক্রিপ্ট এখানে এরর দেয় না! (এটি একটি ছোট ত্রুটি)
```
তাই টাপল ব্যবহারের সময় সরাসরি ইনডেক্স ধরে কাজ করা বা রিড-অনলি (readonly) করে রাখা ভালো।

## Object Types (অবজেক্টের কাঠামো)
জাভাস্ক্রিপ্টে অবজেক্ট যা খুশি হতে পারে। কিন্তু টাইপস্ক্রিপ্টে আমরা অবজেক্টের প্রতিটি "Key" বা প্রপার্টির টাইপ আগে থেকেই ঠিক করে দিই।

```bash
// একটি সাধারণ অবজেক্ট টাইপ ডিক্লেয়ারেশন
let employee: {
    readonly id: number; // এই আইডি পরিবর্তন করা যাবে না
    name: string;
    department?: string; // এখানে '?' মানে এটি অপশনাল (না দিলেও চলবে)
};

employee = {
    id: 101,
    name: "Rahat"
};
```
মেকানিজম: এখানে readonly ব্যবহার করায় আপনি চাইলে পরে employee.id = 200 করতে পারবেন না। এটি বড় অ্যাপ্লিকেশনে ডাটা ইনটিগ্রিটি বজায় রাখে।

## Type Aliases (টাইপ অ্যালিয়াস)
একই অবজেক্ট টাইপ যদি বারবার ব্যবহার করতে হয়, তবে সেটা বারবার লেখা বিরক্তিকর এবং কোড নোংরা করে। তাই আমরা একটি "নাম" বা ডাকনাম দিই। একেই বলে Type Alias।

```bash
// আমরা একটি 'User' টাইপ বানিয়ে নিলাম
type User = {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
};

// এখন এই 'User' নামটা যেকোনো জায়গায় ব্যবহার করা যাবে
const user1: User = {
    id: 1,
    name: "Karim",
    email: "karim@test.com",
    isActive: true
};
```

## Type Assertions (টাইপ জোরপূর্বক নির্ধারণ)
মাঝে মাঝে আপনি টাইপস্ক্রিপ্টের চেয়েও বেশি জানেন যে একটি ভেরিয়েবলে কী আছে। তখন আপনি টাইপস্ক্রিপ্টকে বলেন—"শোনো, আমি জানি আমি কী করছি, এটাকে এই টাইপ হিসেবে ধরো।" একেই বলে Type Assertion।

এটি সাধারণত as কীওয়ার্ড দিয়ে করা হয়।

বাস্তব উদাহরণ (DOM Manipulation):
ধরুন আপনি এইচটিএমএল থেকে একটি ইনপুট ফিল্ড ধরছেন। টাইপস্ক্রিপ্ট শুধু জানে এটা একটা Element, কিন্তু আপনি জানেন এটা একটা HTMLInputElement যার ভেতরে .value আছে।

```bash
const myInput = document.getElementById("search-box") as HTMLInputElement;

// এখন TS আমাকে '.value' ব্যবহার করতে দিবে
console.log(myInput.value);
```

unknown এর সাথে ব্যবহার:
আগের মেসেজে আমরা unknown দেখেছিলাম। সেটার সাথে Assertion খুব কাজে দেয়:
```bash
let someValue: unknown = "This is a string";

let strLength: number = (someValue as string).length;
// এখানে আমি TS কে জোর দিয়ে বললাম যে someValue আসলে একটি string।
```
**সতর্কতা: Assertion সাবধানে ব্যবহার করবেন। আপনি যদি ভুল করে একটি নাম্বারকে as string বলেন, তবে কম্পাইল টাইমে এরর আসবে না কিন্তু রানটাইমে আপনার অ্যাপ ক্রাশ করতে পারে।**

## ইন্টারফেস (interface): যখন আপনি অবজেক্টের কাঠামো বা ব্লুপ্রিন্ট চান
ইন্টারফেস মূলত অবজেক্ট এবং ক্লাসের আকার (Shape) নির্ধারণের জন্য তৈরি। এটি অনেকটা "চুক্তি" বা "Contract" এর মতো।

কখন ব্যবহার করবেন?
- Object/Class definition: যখন আপনি কোনো অবজেক্ট বা ক্লাসের প্রপার্টি ডিফাইন করতে চান।

- Declaration Merging: এটি ইন্টারফেসের একটি ইউনিক ক্ষমতা। একই নামে দুটি ইন্টারফেস লিখলে তারা অটোমেটিক মিলে যায় (Merge হয়)।

```ts
interface User {
  name: string;
}

interface User {
  age: number; // এটি আগের User ইন্টারফেসের সাথে যোগ হয়ে যাবে
}

const person: User = { name: "Abir", age: 25 };
```

## টাইপ অ্যালিয়াস (type): যখন আপনি ফ্লেক্সিবিলিটি চান
টাইপ অ্যালিয়াস যেকোনো কিছুর জন্য হতে পারে—অবজেক্ট, ইউনিয়ন, টাপল বা প্রিমিটিভ টাইপ।

কখন ব্যবহার করবেন?
- Union Types: যখন একটি ভেরিয়েবল একাধিক টাইপের হতে পারে (যেমন: string | number)। এটি ইন্টারফেস দিয়ে সম্ভব নয়।

- Tuples: টাপল ডিফাইন করার জন্য টাইপই সেরা।

- Computed Properties: কমপ্লেক্স কোনো টাইপ লজিক তৈরি করতে হলে।

```ts
type ID = string | number; // Union type
type Point = [number, number]; // Tuple
```

টাইপস্ক্রিপ্টে (TypeScript) অবজেক্ট বা ডেটার আকার নির্ধারণ করতে আমরা এই দুটি পদ্ধতি ব্যবহার করি। তাদের পার্থক্য নিচে দেওয়া হলো:

| বৈশিষ্ট্য (Feature) | Interface (ইন্টারফেস) | Type Alias (টাইপ এলিয়াস) |
| :--- | :--- | :--- |
| **অবজেক্ট ও ক্লাস** (Objects & Classes) | খুব ভালোভাবে হ্যান্ডেল করে। | হ্যান্ডেল করতে পারে। |
| **এক্সটেনশন** (Inheritance) | `extends` কীওয়ার্ড ব্যবহার করে। | `&` (Intersection) ব্যবহার করে। |
| **মার্জিং** (Merging) | একই নামে একাধিক থাকলে অটো-মার্জ হয়। | একই নামে দুটি থাকলে এরর (Error) দেয়। |
| **ইউনিয়ন টাইপ** (Union Types) | সাপোর্ট করে না। | দারুণভাবে সাপোর্ট করে। |

## রিয়েল-ওয়ার্ল্ড সিনারিও (Real-world Scenarios)
**সিনারিও ১: আপনি একটি লাইব্রেরি বানাচ্ছেন (Use Interface)**
আপনি যদি এমন একটি প্যাকেজ বানান যা অন্য ডেভেলপাররা ব্যবহার করবে, তবে interface ব্যবহার করা ভালো। কারণ ইউজার চাইলে আপনার ইন্টারফেসটি "Declaration Merging" এর মাধ্যমে এক্সটেন্ড করতে পারবে।

**সিনারিও ২: API রেসপন্স হ্যান্ডেল করা (Use Type)**
API থেকে আসা ডাটা প্রায়ই ডাইনামিক হয়। সেখানে ইউনিয়ন বা ইন্টারসেকশন দরকার পড়ে।

```ts
type SuccessResponse = { data: object; status: 200 };
type ErrorResponse = { error: string; status: 404 };

type ApiResponse = SuccessResponse | ErrorResponse; // ইন্টারফেস দিয়ে এটা করা কঠিন
```

**সিনারিও ৩: রিঅ্যাক্ট প্রপস (React Props)**
সাধারণত রিঅ্যাক্ট কম্পোনেন্টের প্রপস ডিফাইন করার জন্য ডেভেলপাররা interface পছন্দ করেন কারণ এর এরর মেসেজগুলো বেশি পরিষ্কার হয়। তবে যদি আপনার প্রপসে ইউনিয়ন টাইপ লাগে, তবে type ব্যবহার করতেই হবে।

**১. ডিফল্ট হিসেবে interface ব্যবহার করুন—যতক্ষণ না আপনার ইউনিয়ন বা টাপল টাইপের প্রয়োজন পড়ছে। এটি কোডকে বেশি অবজেক্ট-ওরিয়েন্টেড রাখে। ২. পারফরম্যান্স: টাইপস্ক্রিপ্ট ইঞ্জিন ইন্টারফেসের ইনহেরিটেন্স দ্রুত প্রসেস করতে পারে কারণ এটি মেমোরিতে টাইপগুলো ক্যাশ (Cache) করে রাখে, যেখানে type এর ইন্টারসেকশন (&) প্রতিবার নতুন করে ক্যালকুলেট করতে হয়।**

## extends (Interface এর ক্ষমতা)
ইন্টারফেস যখন অন্য একটি ইন্টারফেসের বৈশিষ্ট্য ধার করে, তখন আমরা extends ব্যবহার করি। এটি দেখতে অনেকটা জাভা বা সি-শার্পের ক্লাসিক ইনহেরিটেন্সের মতো।


```ts
interface Animal {
    name: string;
}

interface Dog extends Animal {
    breed: string;
}

const myDog: Dog = {
    name: "Rex",
    breed: "German Shepherd"
};
```

ইন্টারনাল মেকানিজম:

- Hierarchy: এটি একটি হায়ারার্কি বা বংশপরম্পরা তৈরি করে।

- Conflict Checking: যদি Dog-এ এমন কোনো প্রপার্টি থাকে যা Animal-এর সাথে সাংঘর্ষিক (যেমন Animal-এ name হলো string আর Dog-এ আপনি দিতে চাইলেন number), তবে টাইপস্ক্রিপ্ট সাথে সাথে আপনাকে বড় একটি এরর দেবে।

- Performance: ইন্টারফেস যখন extends হয়, তখন টাইপস্ক্রিপ্ট ইঞ্জিন এটি মেমোরিতে ক্যাশ (Cache) করে রাখে। ফলে বড় প্রজেক্টে এটি দ্রুত কাজ করে।

## Intersection (&) (Type Alias এর ক্ষমতা)
ইন্টারসেকশন মানে হলো দুই বা ততোধিক টাইপকে একসাথে জোড়া দিয়ে একটি নতুন টাইপ বানানো। এটি অনেকটা জগাখিচুড়ি পাকানোর মতো—সবকিছু এক জায়গায় চলে আসবে।

```ts
type Flyable = {
    canFly: boolean;
};

type Swimmable = {
    canSwim: boolean;
};

type SuperDuck = Flyable & Swimmable;

const duck: SuperDuck = {
    canFly: true,
    canSwim: true
};
```

ইন্টারনাল মেকানিজম:

- Recursive Merging: এটি কোনো বংশপরম্পরা মানে না, শুধু প্রপার্টিগুলো একটার সাথে আরেকটা মিলিয়ে দেয়।

- Never Type Conflict: যদি দুটি টাইপে একই নামের প্রপার্টি থাকে কিন্তু তাদের টাইপ আলাদা হয় (যেমন একটিতে id: string অন্যটিতে id: number), তবে ইন্টারসেকশন করার পর সেটি never টাইপ হয়ে যায়। কারণ কোনো কিছু একই সাথে স্ট্রিং এবং নাম্বার হতে পারে না। ফলে আপনার অবজেক্টটি ব্যবহার অনুপযোগী হয়ে পড়ে।

## রিয়েল-ওয়ার্ল্ড সিনারিও (কখন কোনটি?)
কখন extends ব্যবহার করবেন?
যখন আপনি একটি পরিষ্কার কাঠামো বা আর্কিটেকচার তৈরি করছেন। যেমন একটি বেস User থেকে Admin এবং Customer তৈরি করা। এতে কোড রিডাবিলিটি ভালো থাকে।

কখন & (Intersection) ব্যবহার করবেন?
যখন আপনার হুট করে দুটি আলাদা জিনিসের বৈশিষ্ট্য এক জায়গায় দরকার। ধরুন একটি Log টাইপ আর একটি User টাইপ আছে, আপনি এখন একটি ফাংশনে এই দুইটার কম্বিনেশন চাচ্ছেন। এছাড়া Union Types-এর সাথে কাজ করতে হলে ইন্টারসেকশন ছাড়া উপায় নেই।

**আপনি যদি পারফরম্যান্স এবং ক্লিন এরর মেসেজ চান, তবে সবসময় interface এবং extends আগে ব্যবহার করার চেষ্টা করবেন। আর যদি আপনি অ্যাডভান্সড কোনো টাইপ ম্যানিপুলেশন করেন (যেখানে ইউনিয়ন বা প্রিমিটিভ টাইপ আছে), তখন & ব্যবহার করবেন।**


## Literal Types (সুনির্দিষ্ট মান)
সাধারণত string বা number বললে আমরা যেকোনো টেক্সট বা সংখ্যা বুঝি। কিন্তু Literal Type মানে হলো ভ্যালুটা ঠিক কী হবে, সেটাও বলে দেওয়া।

- স্বভাব: এটি ভেরিয়েবলকে শুধু একটি নির্দিষ্ট মানে সীমাবদ্ধ করে ফেলে।

- কেন ব্যবহার করবেন: যখন আপনি জানেন যে একটি ভ্যালু মাত্র ২-৩টি অপশনের মধ্যেই হবে (যেমন: চাকুরির স্ট্যাটাস বা পেমেন্ট মেথড)।

```ts
let direction: "left" | "right" | "up" | "down";

direction = "left";  // OK
// direction = "north"; // Error: "north" ইজ নট অ্যাসাইনেবল।
```

## Type Narrowing এবং Type Guards: "শনাক্ত করা"
আপনার কাছে একটি পার্সেল আসলো যার ভেতরে হয় একটি মোবাইল আছে, না হয় একটি বই আছে। কিন্তু পার্সেল না খুলে আপনি জানেন না ভেতরে কী। আপনি যদি না দেখেই চার্জার লাগাতে যান এবং ভেতরে বই থাকে, তবে তো বিপদ!

Narrowing মানে হলো পার্সেল খুলে নিশ্চিত হওয়া যে ভেতরে আসলে কী আছে, যাতে আপনি সঠিক কাজটা করতে পারেন।

### typeof (কি ধরনের ডাটা?)
যদি ডাটাটি সাধারণ হয় (যেমন: string, number), তখন আমরা typeof ব্যবহার করি।

```ts
function printSize(input: string | number) {
  if (typeof input === "string") {
    // এখানে ইনপুট নিশ্চিতভাবেই string। তাই আমরা .length দেখতে পারি।
    console.log(input.length);
  } else {
    // এখানে ইনপুট নিশ্চিতভাবেই number।
    console.log(input.toFixed(2));
  }
}
```
### in Operator (ভিতরে কী আছে?)
ধরুন আপনার কাছে দুটি বাক্স আছে। একটার গায়ে লেখা 'Screen' (মোবাইল), আরেকটার গায়ে লেখা 'Pages' (বই)। আপনি যদি বাক্সের গায়ে 'Pages' লেখা দেখেন, আপনি নিশ্চিত যে এটা বই।

```ts
type Mobile = { screen: string };
type Book = { pages: number };

function check(item: Mobile | Book) {
  if ("pages" in item) {
    // 'pages' যার আছে সে তো নিশ্চিতভাবেই 'Book'
    console.log("এটা একটা বই, যার পৃষ্ঠা সংখ্যা:", item.pages);
  }
}
```

### Custom Type Guard: "নিজের তৈরি ডিটেক্টর"
মাঝে মাঝে টাইপস্ক্রিপ্ট নিজে থেকে বুঝতে পারে না। তখন আপনাকে একটি ফাংশন বানিয়ে দিতে হয় যা চেক করে বলবে এটা কী।

উদাহরণ: আপনি একটি ফাংশন বানালেন যা চেক করবে মাছের কি "পাখনা" (Fin) আছে কি না। যদি থাকে, তবে সে নিশ্চিত করবে এটা একটা "মাছ"।

```ts
interface Fish { swim: () => void }
interface Bird { fly: () => void }

// এই ফাংশনটি টাইপস্ক্রিপ্টকে 'নিশ্চিত' (is) করে বলে দিবে
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

function move(pet: Fish | Bird) {
  if (isFish(pet)) {
    pet.swim(); // এখন TS ভয় পাবে না, সে জানে এটা মাছই!
  } else {
    pet.fly(); // মাছ না হলে পাখিই হবে
  }
}
```

## Generics মানে হলো "Type Variable"। আমরা যেমন ফাংশনে 'ভ্যালু' পাস করি, জেনেরিক্সে আমরা 'টাইপ' পাস করি।

### জেনেরিক্স (Generics) কেন দরকার? (The Problem)
ধরুন, আপনার কাছে একটি ফাংশন আছে যা একটি অ্যারে থেকে শেষ এলিমেন্টটা রিটার্ন করবে।

- যদি আপনি number[] দেন, সে number রিটার্ন করবে।

- যদি আপনি string[] দেন, সে string রিটার্ন করবে।

সমস্যা: আপনি যদি টাইপ any দেন, তবে টাইপ সেফটি হারিয়ে যাবে। আর যদি টাইপ ফিক্সড করে দেন, তবে অন্য টাইপের জন্য আলাদা ফাংশন লিখতে হবে।

## জেনেরিক্স সমাধান (The Concept)
আমরা ফাংশনের নামের পাশে <T> লিখি। এই T হলো একটি প্লেসহোল্ডার বা ভেরিয়েবল, যেখানে আপনি পরে যেকোনো টাইপ বসাতে পারবেন।

```ts
function getLastElement<T>(arr: T[]): T {
    return arr[arr.length - 1];
}

// ব্যবহারের সময়:
const lastNum = getLastElement<number>([10, 20, 30]); // T এখানে number
const lastStr = getLastElement<string>(["Apple", "Banana"]); // T এখানে string
```
এখানে কী ঘটল? যখন আপনি <number> পাস করলেন, টাইপস্ক্রিপ্ট ফাংশনটির সব T কে number দিয়ে রিপ্লেস করে দিল। এর ফলে আপনি কোড লিখলেন একবার, কিন্তু এটি সব ধরনের টাইপের জন্য কাজ করল।

## Generic Interfaces & Types
শুধু ফাংশন নয়, আপনি ইন্টারফেস বা টাইপকেও জেনেরিক বানাতে পারেন। যেমন একটি API রেসপন্স এর কাঠামো:

```ts
interface ApiResponse<T> {
    status: number;
    data: T; // এখানে ডাটা যেকোনো কিছু হতে পারে
    message: string;
}

const userResponse: ApiResponse<{ name: string; age: number }> = {
    status: 200,
    data: { name: "Sakib", age: 25 },
    message: "Success"
};
```

## Generic Constraints (সীমাবদ্ধতা দেওয়া)
মাঝে মাঝে আপনি চান T যেকোনো টাইপ হোক, কিন্তু তার অন্তত কিছু নির্দিষ্ট প্রপার্টি থাকুক। একে বলে Constraints (ব্যবহার করা হয় extends কীওয়ার্ড)।

ধরুন, আপনি এমন একটি ফাংশন চান যা সবকিছুর .length প্রিন্ট করবে। কিন্তু সব ডাটার তো আর .length নেই (যেমন নাম্বারের নেই)।

```ts
interface HasLength {
    length: number;
}

function printLength<T extends HasLength>(item: T) {
    console.log(item.length);
}

printLength("Hello"); // OK (স্ট্রিংয়ের লেন্থ আছে)
printLength([1, 2, 3]); // OK (অ্যারের লেন্থ আছে)
// printLength(10); // Error! (নাম্বারের লেন্থ নেই)
```

## Multiple Generics (একাধিক জেনেরিক)
আপনি চাইলে একটি ফাংশনে একাধিক টাইপ ভেরিয়েবল ব্যবহার করতে পারেন।
```ts

function mergeObjects<T, U>(obj1: T, obj2: U) {
    return { ...obj1, ...obj2 };
}

const combined = mergeObjects({ name: "Rohan" }, { id: 501 });
// combined এখন { name: string } & { id: number } টাইপ হয়ে গেল।
```

**স্টাফ ইঞ্জিনিয়ার পারসপেক্টিভ: জেনেরিক্স কেন শিখবেন?
১. Code Reusability: একই লজিক বারবার না লিখে একবার জেনেরিক ফাংশন লিখে রাখুন। ২. Type Safety with Flexibility: any ব্যবহার না করেই ডাইনামিক ডাটা হ্যান্ডেল করা যায়। ৩. Library Development: আপনি যদি নিজের কোনো প্লাগইন বা লাইব্রেরি বানাতে চান, জেনেরিক্স ছাড়া আপনি প্রো-লেভেলের কোড লিখতে পারবেন না।**
