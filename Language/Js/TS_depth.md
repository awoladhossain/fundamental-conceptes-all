## অ্যারে (Array): "একই জাতের মেলা"
অ্যারে হলো এমন একটি লিস্ট যেখানে আপনি একই ধরনের অনেকগুলো ডাটা রাখতে পারেন। এর কোনো নির্দিষ্ট লিমিট নেই—আপনি যত খুশি ডাটা যোগ করতে পারেন।

```bash
let friends: string[] = ["Sakib", "Rakib", "Tamim"];
// অথবা
let salary: Array<number> = [25000, 30000, 45000];
```

## টাপল (Tuple): "ফিক্সড বা নির্দিষ্ট সেট"
এটিই হলো টাইপস্ক্রিপ্টের স্পেশাল ফিচার। টাপল হলো এমন এক ধরনের অ্যারে যেখানে:

1. ডাটা সংখ্যা ফিক্সড (কয়টা এলিমেন্ট থাকবে তা আগে থেকেই বলা থাকে)।
2. প্রতিটি পজিশনে কোন ধরনের ডাটা থাকবে তা নির্দিষ্ট।

```bash
let person: [number, string, boolean];

person = [1, "Anis", true]; // একদম সঠিক
// person = ["Anis", 1, true]; // ভুল! কারণ প্রথমে নাম্বার থাকার কথা ছিল।
```


**টাপল হলো আপনার মানিব্যাগের মতো। ধরুন আপনার মানিব্যাগে ৩টি পকেট আছে: প্রথম পকেটে শুধু 'টাকা' (Number), দ্বিতীয় পকেটে 'আইডি কার্ড' (String), আর তৃতীয় পকেটে 'বাসের টিকিট' (Boolean) থাকবে। আপনি চাইলে হুট করে পকেট বাড়াতে পারবেন না, আর এক পকেটের জিনিস অন্য পকেটে রাখতে পারবেন না।**

## ইন-ডেপথ মেকানিজম: কেন টাপল ব্যবহার করবেন?

একজন স্টাফ ইঞ্জিনিয়ার হিসেবে আমি তখনই টাপল ব্যবহার করি যখন আমি নিশ্চিত যে ডাটার স্ট্রাকচার বদলাবে না।

উদাহরণ: HTTP Status Code আপনি একটি API রেসপন্স পাঠাচ্ছেন যেখানে প্রথমটা হবে স্ট্যাটাস কোড (Number) আর দ্বিতীয়টা হবে মেসেজ (String)।

```bash
type Response = [number, string];

const success: Response = [200, "Success"];
const notFound: Response = [404, "Not Found"];
```

এখানে যদি ভুল করে কেউ ["Success", 200] লিখে ফেলে, তবে টাইপস্ক্রিপ্ট কম্পাইল করার আগেই এরর দেবে। জাভাস্ক্রিপ্টে এই ভুলটা ধরা খুব কঠিন হতো।

## একটি "বিপজ্জনক" বিষয় (Interview Secret)
টাপলের একটি সীমাবদ্ধতা আছে যা অনেক সিনিয়র ডেভেলপারও ভুল করেন। যদিও আমরা বলি টাপল "ফিক্সড", কিন্তু আপনি যদি .push() মেথড ব্যবহার করেন, তবে টাপলে নতুন ডাটা ঢুকে যায়!

```bash
let myTuple: [number, string] = [1, "Hello"];
myTuple.push(100); // টাইপস্ক্রিপ্ট এখানে এরর দেয় না! (এটি একটি ছোট ত্রুটি)
```
তাই টাপল ব্যবহারের সময় সরাসরি ইনডেক্স ধরে কাজ করা বা রিড-অনলি (readonly) করে রাখা ভালো।

## Object Types (অবজেক্টের কাঠামো)
জাভাস্ক্রিপ্টে অবজেক্ট যা খুশি হতে পারে। কিন্তু টাইপস্ক্রিপ্টে আমরা অবজেক্টের প্রতিটি "Key" বা প্রপার্টির টাইপ আগে থেকেই ঠিক করে দিই।

```bash
// একটি সাধারণ অবজেক্ট টাইপ ডিক্লেয়ারেশন
let employee: {
    readonly id: number; // এই আইডি পরিবর্তন করা যাবে না
    name: string;
    department?: string; // এখানে '?' মানে এটি অপশনাল (না দিলেও চলবে)
};

employee = {
    id: 101,
    name: "Rahat"
};
```
মেকানিজম: এখানে readonly ব্যবহার করায় আপনি চাইলে পরে employee.id = 200 করতে পারবেন না। এটি বড় অ্যাপ্লিকেশনে ডাটা ইনটিগ্রিটি বজায় রাখে।

## Type Aliases (টাইপ অ্যালিয়াস)
একই অবজেক্ট টাইপ যদি বারবার ব্যবহার করতে হয়, তবে সেটা বারবার লেখা বিরক্তিকর এবং কোড নোংরা করে। তাই আমরা একটি "নাম" বা ডাকনাম দিই। একেই বলে Type Alias।

```bash
// আমরা একটি 'User' টাইপ বানিয়ে নিলাম
type User = {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
};

// এখন এই 'User' নামটা যেকোনো জায়গায় ব্যবহার করা যাবে
const user1: User = {
    id: 1,
    name: "Karim",
    email: "karim@test.com",
    isActive: true
};
```

## Type Assertions (টাইপ জোরপূর্বক নির্ধারণ)
মাঝে মাঝে আপনি টাইপস্ক্রিপ্টের চেয়েও বেশি জানেন যে একটি ভেরিয়েবলে কী আছে। তখন আপনি টাইপস্ক্রিপ্টকে বলেন—"শোনো, আমি জানি আমি কী করছি, এটাকে এই টাইপ হিসেবে ধরো।" একেই বলে Type Assertion।

এটি সাধারণত as কীওয়ার্ড দিয়ে করা হয়।

বাস্তব উদাহরণ (DOM Manipulation):
ধরুন আপনি এইচটিএমএল থেকে একটি ইনপুট ফিল্ড ধরছেন। টাইপস্ক্রিপ্ট শুধু জানে এটা একটা Element, কিন্তু আপনি জানেন এটা একটা HTMLInputElement যার ভেতরে .value আছে।

```bash
const myInput = document.getElementById("search-box") as HTMLInputElement;

// এখন TS আমাকে '.value' ব্যবহার করতে দিবে
console.log(myInput.value);
```

unknown এর সাথে ব্যবহার:
আগের মেসেজে আমরা unknown দেখেছিলাম। সেটার সাথে Assertion খুব কাজে দেয়:
```bash
let someValue: unknown = "This is a string";

let strLength: number = (someValue as string).length;
// এখানে আমি TS কে জোর দিয়ে বললাম যে someValue আসলে একটি string।
```
**সতর্কতা: Assertion সাবধানে ব্যবহার করবেন। আপনি যদি ভুল করে একটি নাম্বারকে as string বলেন, তবে কম্পাইল টাইমে এরর আসবে না কিন্তু রানটাইমে আপনার অ্যাপ ক্রাশ করতে পারে।**

## ইন্টারফেস (interface): যখন আপনি অবজেক্টের কাঠামো বা ব্লুপ্রিন্ট চান
ইন্টারফেস মূলত অবজেক্ট এবং ক্লাসের আকার (Shape) নির্ধারণের জন্য তৈরি। এটি অনেকটা "চুক্তি" বা "Contract" এর মতো।

কখন ব্যবহার করবেন?
- Object/Class definition: যখন আপনি কোনো অবজেক্ট বা ক্লাসের প্রপার্টি ডিফাইন করতে চান।

- Declaration Merging: এটি ইন্টারফেসের একটি ইউনিক ক্ষমতা। একই নামে দুটি ইন্টারফেস লিখলে তারা অটোমেটিক মিলে যায় (Merge হয়)।

```ts
interface User {
  name: string;
}

interface User {
  age: number; // এটি আগের User ইন্টারফেসের সাথে যোগ হয়ে যাবে
}

const person: User = { name: "Abir", age: 25 };
```

## টাইপ অ্যালিয়াস (type): যখন আপনি ফ্লেক্সিবিলিটি চান
টাইপ অ্যালিয়াস যেকোনো কিছুর জন্য হতে পারে—অবজেক্ট, ইউনিয়ন, টাপল বা প্রিমিটিভ টাইপ।

কখন ব্যবহার করবেন?
- Union Types: যখন একটি ভেরিয়েবল একাধিক টাইপের হতে পারে (যেমন: string | number)। এটি ইন্টারফেস দিয়ে সম্ভব নয়।

- Tuples: টাপল ডিফাইন করার জন্য টাইপই সেরা।

- Computed Properties: কমপ্লেক্স কোনো টাইপ লজিক তৈরি করতে হলে।

```ts
type ID = string | number; // Union type
type Point = [number, number]; // Tuple
```

টাইপস্ক্রিপ্টে (TypeScript) অবজেক্ট বা ডেটার আকার নির্ধারণ করতে আমরা এই দুটি পদ্ধতি ব্যবহার করি। তাদের পার্থক্য নিচে দেওয়া হলো:

| বৈশিষ্ট্য (Feature) | Interface (ইন্টারফেস) | Type Alias (টাইপ এলিয়াস) |
| :--- | :--- | :--- |
| **অবজেক্ট ও ক্লাস** (Objects & Classes) | খুব ভালোভাবে হ্যান্ডেল করে। | হ্যান্ডেল করতে পারে। |
| **এক্সটেনশন** (Inheritance) | `extends` কীওয়ার্ড ব্যবহার করে। | `&` (Intersection) ব্যবহার করে। |
| **মার্জিং** (Merging) | একই নামে একাধিক থাকলে অটো-মার্জ হয়। | একই নামে দুটি থাকলে এরর (Error) দেয়। |
| **ইউনিয়ন টাইপ** (Union Types) | সাপোর্ট করে না। | দারুণভাবে সাপোর্ট করে। |

## রিয়েল-ওয়ার্ল্ড সিনারিও (Real-world Scenarios)
**সিনারিও ১: আপনি একটি লাইব্রেরি বানাচ্ছেন (Use Interface)**
আপনি যদি এমন একটি প্যাকেজ বানান যা অন্য ডেভেলপাররা ব্যবহার করবে, তবে interface ব্যবহার করা ভালো। কারণ ইউজার চাইলে আপনার ইন্টারফেসটি "Declaration Merging" এর মাধ্যমে এক্সটেন্ড করতে পারবে।

**সিনারিও ২: API রেসপন্স হ্যান্ডেল করা (Use Type)**
API থেকে আসা ডাটা প্রায়ই ডাইনামিক হয়। সেখানে ইউনিয়ন বা ইন্টারসেকশন দরকার পড়ে।

```ts
type SuccessResponse = { data: object; status: 200 };
type ErrorResponse = { error: string; status: 404 };

type ApiResponse = SuccessResponse | ErrorResponse; // ইন্টারফেস দিয়ে এটা করা কঠিন
```

**সিনারিও ৩: রিঅ্যাক্ট প্রপস (React Props)**
সাধারণত রিঅ্যাক্ট কম্পোনেন্টের প্রপস ডিফাইন করার জন্য ডেভেলপাররা interface পছন্দ করেন কারণ এর এরর মেসেজগুলো বেশি পরিষ্কার হয়। তবে যদি আপনার প্রপসে ইউনিয়ন টাইপ লাগে, তবে type ব্যবহার করতেই হবে।

**১. ডিফল্ট হিসেবে interface ব্যবহার করুন—যতক্ষণ না আপনার ইউনিয়ন বা টাপল টাইপের প্রয়োজন পড়ছে। এটি কোডকে বেশি অবজেক্ট-ওরিয়েন্টেড রাখে। ২. পারফরম্যান্স: টাইপস্ক্রিপ্ট ইঞ্জিন ইন্টারফেসের ইনহেরিটেন্স দ্রুত প্রসেস করতে পারে কারণ এটি মেমোরিতে টাইপগুলো ক্যাশ (Cache) করে রাখে, যেখানে type এর ইন্টারসেকশন (&) প্রতিবার নতুন করে ক্যালকুলেট করতে হয়।**

## extends (Interface এর ক্ষমতা)
ইন্টারফেস যখন অন্য একটি ইন্টারফেসের বৈশিষ্ট্য ধার করে, তখন আমরা extends ব্যবহার করি। এটি দেখতে অনেকটা জাভা বা সি-শার্পের ক্লাসিক ইনহেরিটেন্সের মতো।


```ts
interface Animal {
    name: string;
}

interface Dog extends Animal {
    breed: string;
}

const myDog: Dog = {
    name: "Rex",
    breed: "German Shepherd"
};
```

ইন্টারনাল মেকানিজম:

- Hierarchy: এটি একটি হায়ারার্কি বা বংশপরম্পরা তৈরি করে।

- Conflict Checking: যদি Dog-এ এমন কোনো প্রপার্টি থাকে যা Animal-এর সাথে সাংঘর্ষিক (যেমন Animal-এ name হলো string আর Dog-এ আপনি দিতে চাইলেন number), তবে টাইপস্ক্রিপ্ট সাথে সাথে আপনাকে বড় একটি এরর দেবে।

- Performance: ইন্টারফেস যখন extends হয়, তখন টাইপস্ক্রিপ্ট ইঞ্জিন এটি মেমোরিতে ক্যাশ (Cache) করে রাখে। ফলে বড় প্রজেক্টে এটি দ্রুত কাজ করে।

## Intersection (&) (Type Alias এর ক্ষমতা)
ইন্টারসেকশন মানে হলো দুই বা ততোধিক টাইপকে একসাথে জোড়া দিয়ে একটি নতুন টাইপ বানানো। এটি অনেকটা জগাখিচুড়ি পাকানোর মতো—সবকিছু এক জায়গায় চলে আসবে।

```ts
type Flyable = {
    canFly: boolean;
};

type Swimmable = {
    canSwim: boolean;
};

type SuperDuck = Flyable & Swimmable;

const duck: SuperDuck = {
    canFly: true,
    canSwim: true
};
```

ইন্টারনাল মেকানিজম:

- Recursive Merging: এটি কোনো বংশপরম্পরা মানে না, শুধু প্রপার্টিগুলো একটার সাথে আরেকটা মিলিয়ে দেয়।

- Never Type Conflict: যদি দুটি টাইপে একই নামের প্রপার্টি থাকে কিন্তু তাদের টাইপ আলাদা হয় (যেমন একটিতে id: string অন্যটিতে id: number), তবে ইন্টারসেকশন করার পর সেটি never টাইপ হয়ে যায়। কারণ কোনো কিছু একই সাথে স্ট্রিং এবং নাম্বার হতে পারে না। ফলে আপনার অবজেক্টটি ব্যবহার অনুপযোগী হয়ে পড়ে।

## রিয়েল-ওয়ার্ল্ড সিনারিও (কখন কোনটি?)
কখন extends ব্যবহার করবেন?
যখন আপনি একটি পরিষ্কার কাঠামো বা আর্কিটেকচার তৈরি করছেন। যেমন একটি বেস User থেকে Admin এবং Customer তৈরি করা। এতে কোড রিডাবিলিটি ভালো থাকে।

কখন & (Intersection) ব্যবহার করবেন?
যখন আপনার হুট করে দুটি আলাদা জিনিসের বৈশিষ্ট্য এক জায়গায় দরকার। ধরুন একটি Log টাইপ আর একটি User টাইপ আছে, আপনি এখন একটি ফাংশনে এই দুইটার কম্বিনেশন চাচ্ছেন। এছাড়া Union Types-এর সাথে কাজ করতে হলে ইন্টারসেকশন ছাড়া উপায় নেই।

**আপনি যদি পারফরম্যান্স এবং ক্লিন এরর মেসেজ চান, তবে সবসময় interface এবং extends আগে ব্যবহার করার চেষ্টা করবেন। আর যদি আপনি অ্যাডভান্সড কোনো টাইপ ম্যানিপুলেশন করেন (যেখানে ইউনিয়ন বা প্রিমিটিভ টাইপ আছে), তখন & ব্যবহার করবেন।**


## Literal Types (সুনির্দিষ্ট মান)
সাধারণত string বা number বললে আমরা যেকোনো টেক্সট বা সংখ্যা বুঝি। কিন্তু Literal Type মানে হলো ভ্যালুটা ঠিক কী হবে, সেটাও বলে দেওয়া।

- স্বভাব: এটি ভেরিয়েবলকে শুধু একটি নির্দিষ্ট মানে সীমাবদ্ধ করে ফেলে।

- কেন ব্যবহার করবেন: যখন আপনি জানেন যে একটি ভ্যালু মাত্র ২-৩টি অপশনের মধ্যেই হবে (যেমন: চাকুরির স্ট্যাটাস বা পেমেন্ট মেথড)।

```ts
let direction: "left" | "right" | "up" | "down";

direction = "left";  // OK
// direction = "north"; // Error: "north" ইজ নট অ্যাসাইনেবল।
```

## Type Narrowing এবং Type Guards: "শনাক্ত করা"
আপনার কাছে একটি পার্সেল আসলো যার ভেতরে হয় একটি মোবাইল আছে, না হয় একটি বই আছে। কিন্তু পার্সেল না খুলে আপনি জানেন না ভেতরে কী। আপনি যদি না দেখেই চার্জার লাগাতে যান এবং ভেতরে বই থাকে, তবে তো বিপদ!

Narrowing মানে হলো পার্সেল খুলে নিশ্চিত হওয়া যে ভেতরে আসলে কী আছে, যাতে আপনি সঠিক কাজটা করতে পারেন।

### typeof (কি ধরনের ডাটা?)
যদি ডাটাটি সাধারণ হয় (যেমন: string, number), তখন আমরা typeof ব্যবহার করি।

```ts
function printSize(input: string | number) {
  if (typeof input === "string") {
    // এখানে ইনপুট নিশ্চিতভাবেই string। তাই আমরা .length দেখতে পারি।
    console.log(input.length);
  } else {
    // এখানে ইনপুট নিশ্চিতভাবেই number।
    console.log(input.toFixed(2));
  }
}
```
### in Operator (ভিতরে কী আছে?)
ধরুন আপনার কাছে দুটি বাক্স আছে। একটার গায়ে লেখা 'Screen' (মোবাইল), আরেকটার গায়ে লেখা 'Pages' (বই)। আপনি যদি বাক্সের গায়ে 'Pages' লেখা দেখেন, আপনি নিশ্চিত যে এটা বই।

```ts
type Mobile = { screen: string };
type Book = { pages: number };

function check(item: Mobile | Book) {
  if ("pages" in item) {
    // 'pages' যার আছে সে তো নিশ্চিতভাবেই 'Book'
    console.log("এটা একটা বই, যার পৃষ্ঠা সংখ্যা:", item.pages);
  }
}
```

### Custom Type Guard: "নিজের তৈরি ডিটেক্টর"
মাঝে মাঝে টাইপস্ক্রিপ্ট নিজে থেকে বুঝতে পারে না। তখন আপনাকে একটি ফাংশন বানিয়ে দিতে হয় যা চেক করে বলবে এটা কী।

উদাহরণ: আপনি একটি ফাংশন বানালেন যা চেক করবে মাছের কি "পাখনা" (Fin) আছে কি না। যদি থাকে, তবে সে নিশ্চিত করবে এটা একটা "মাছ"।

```ts
interface Fish { swim: () => void }
interface Bird { fly: () => void }

// এই ফাংশনটি টাইপস্ক্রিপ্টকে 'নিশ্চিত' (is) করে বলে দিবে
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

function move(pet: Fish | Bird) {
  if (isFish(pet)) {
    pet.swim(); // এখন TS ভয় পাবে না, সে জানে এটা মাছই!
  } else {
    pet.fly(); // মাছ না হলে পাখিই হবে
  }
}
```

## Generics মানে হলো "Type Variable"। আমরা যেমন ফাংশনে 'ভ্যালু' পাস করি, জেনেরিক্সে আমরা 'টাইপ' পাস করি।

### জেনেরিক্স (Generics) কেন দরকার? (The Problem)
ধরুন, আপনার কাছে একটি ফাংশন আছে যা একটি অ্যারে থেকে শেষ এলিমেন্টটা রিটার্ন করবে।

- যদি আপনি number[] দেন, সে number রিটার্ন করবে।

- যদি আপনি string[] দেন, সে string রিটার্ন করবে।

সমস্যা: আপনি যদি টাইপ any দেন, তবে টাইপ সেফটি হারিয়ে যাবে। আর যদি টাইপ ফিক্সড করে দেন, তবে অন্য টাইপের জন্য আলাদা ফাংশন লিখতে হবে।

## জেনেরিক্স সমাধান (The Concept)
আমরা ফাংশনের নামের পাশে <T> লিখি। এই T হলো একটি প্লেসহোল্ডার বা ভেরিয়েবল, যেখানে আপনি পরে যেকোনো টাইপ বসাতে পারবেন।

```ts
function getLastElement<T>(arr: T[]): T {
    return arr[arr.length - 1];
}

// ব্যবহারের সময়:
const lastNum = getLastElement<number>([10, 20, 30]); // T এখানে number
const lastStr = getLastElement<string>(["Apple", "Banana"]); // T এখানে string
```
এখানে কী ঘটল? যখন আপনি <number> পাস করলেন, টাইপস্ক্রিপ্ট ফাংশনটির সব T কে number দিয়ে রিপ্লেস করে দিল। এর ফলে আপনি কোড লিখলেন একবার, কিন্তু এটি সব ধরনের টাইপের জন্য কাজ করল।

## Generic Interfaces & Types
শুধু ফাংশন নয়, আপনি ইন্টারফেস বা টাইপকেও জেনেরিক বানাতে পারেন। যেমন একটি API রেসপন্স এর কাঠামো:

```ts
interface ApiResponse<T> {
    status: number;
    data: T; // এখানে ডাটা যেকোনো কিছু হতে পারে
    message: string;
}

const userResponse: ApiResponse<{ name: string; age: number }> = {
    status: 200,
    data: { name: "Sakib", age: 25 },
    message: "Success"
};
```

## Generic Constraints (সীমাবদ্ধতা দেওয়া)
মাঝে মাঝে আপনি চান T যেকোনো টাইপ হোক, কিন্তু তার অন্তত কিছু নির্দিষ্ট প্রপার্টি থাকুক। একে বলে Constraints (ব্যবহার করা হয় extends কীওয়ার্ড)।

ধরুন, আপনি এমন একটি ফাংশন চান যা সবকিছুর .length প্রিন্ট করবে। কিন্তু সব ডাটার তো আর .length নেই (যেমন নাম্বারের নেই)।

```ts
interface HasLength {
    length: number;
}

function printLength<T extends HasLength>(item: T) {
    console.log(item.length);
}

printLength("Hello"); // OK (স্ট্রিংয়ের লেন্থ আছে)
printLength([1, 2, 3]); // OK (অ্যারের লেন্থ আছে)
// printLength(10); // Error! (নাম্বারের লেন্থ নেই)
```

## Multiple Generics (একাধিক জেনেরিক)
আপনি চাইলে একটি ফাংশনে একাধিক টাইপ ভেরিয়েবল ব্যবহার করতে পারেন।
```ts

function mergeObjects<T, U>(obj1: T, obj2: U) {
    return { ...obj1, ...obj2 };
}

const combined = mergeObjects({ name: "Rohan" }, { id: 501 });
// combined এখন { name: string } & { id: number } টাইপ হয়ে গেল।
```

**স্টাফ ইঞ্জিনিয়ার পারসপেক্টিভ: জেনেরিক্স কেন শিখবেন?
১. Code Reusability: একই লজিক বারবার না লিখে একবার জেনেরিক ফাংশন লিখে রাখুন। ২. Type Safety with Flexibility: any ব্যবহার না করেই ডাইনামিক ডাটা হ্যান্ডেল করা যায়। ৩. Library Development: আপনি যদি নিজের কোনো প্লাগইন বা লাইব্রেরি বানাতে চান, জেনেরিক্স ছাড়া আপনি প্রো-লেভেলের কোড লিখতে পারবেন না।**


## Partial<T> (সবকিছুকে অপশনাল করা)
ধরুন, আপনার একটা User ইন্টারফেস আছে যেখানে name, email, এবং age দিতেই হবে (Required)। কিন্তু আপনি এমন একটা ফাংশন লিখছেন যেটা দিয়ে ইউজার তার প্রোফাইল Update করবে। এখন প্রোফাইল আপডেট করার সময় তো ইউজার সব ডাটা নাও দিতে পারে, সে হয়তো শুধু নাম পাল্টাবে।

এখানেই আসে Partial। এটি একটি টাইপের সব প্রপার্টিকে Optional (?) বানিয়ে দেয়।

```ts
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// Partial ব্যবহার করায় এখন name, email বা age না দিলেও TS এরর দিবে না
function updateUser(id: number, updates: Partial<User>) {
  console.log(`Updating user ${id} with:`, updates);
}

updateUser(1, { name: "Sakib" }); // OK! শুধু নাম দিচ্ছি
updateUser(2, { age: 25, email: "s@test.com" }); // OK!
```

**পেছনের কাহিনী: Partial<User> মনে মনে সব প্রপার্টির শেষে একটা ? বসিয়ে দেয়: { id?: number; name?: string; ... }**

## Omit<T, Keys> (নির্দিষ্ট কিছু বাদ দেওয়া)
Omit মানে হলো কোনো একটা টাইপ থেকে নির্দিষ্ট কিছু প্রপার্টি বাদ দিয়ে নতুন একটা টাইপ তৈরি করা।

উদাহরণ: ধরুন আপনি ডাটাবেস থেকে ইউজার ডাটা পাচ্ছেন। সেখানে পাসওয়ার্ডও আছে। কিন্তু আপনি যখন ফ্রন্টএন্ডে বা অন্য কোথাও ইউজার অবজেক্টটা পাঠাবেন, তখন আপনি চান না যে সেখানে password থাকুক।

```ts
interface UserAccount {
  id: number;
  name: string;
  email: string;
  password: string; // আমরা এটা বাদ দিতে চাই
}

// UserAccount থেকে 'password' বাদ দিয়ে নতুন টাইপ তৈরি করা
type UserWithoutPassword = Omit<UserAccount, "password">;

const publicInfo: UserWithoutPassword = {
  id: 1,
  name: "Rahat",
  email: "rahat@example.com"
  // password: "123" // এখানে পাসওয়ার্ড লিখলে TS এরর দিবে!
};
```

## বোনাস: Pick<T, Keys> (Omit এর উল্টো)
যেহেতু আপনি Omit শিখছেন, তাই Pick জেনে রাখা ভালো। Omit যদি বাদ দেয়, Pick শুধু সেইগুলোকেই তুলে নিয়ে আসে যেগুলো আপনি বলে দিবেন।

```ts
// UserAccount থেকে শুধু name আর email তুলে আনা
type UserContact = Pick<UserAccount, "name" | "email">;

const contact: UserContact = {
  name: "Karim",
  email: "k@test.com"
};
```

**Partial<T>: সব প্রপার্টিকে অপশনাল করার জন্য। (সবচেয়ে বেশি লাগে Update বা Edit ফিচারে)।**
**Omit<T, K>: নির্দিষ্ট কিছু প্রপার্টি (যেমন: Sensitive data বা IDs) বাদ দিয়ে ক্লিন অবজেক্ট তৈরির জন্য।**
**Pick<T, K>: বড় অবজেক্ট থেকে শুধু দরকারি ১-২টি প্রপার্টি আলাদা করার জন্য।**


## Enum হলো এমন একটি নেমস্পেসড ডিক্লেয়ারেশন (Namespaced Declaration) যা ডেভেলপারকে কোডের মধ্যে 'ম্যাজিক নাম্বার' বা 'হার্ডকোডেড স্ট্রিং' পরিহার করে একটি রিডাবল (Readable) এবং টাইপ-সেফ সেট তৈরি করতে দেয়।

1. Enum কেন ব্যবহার করবেন? (The "Why")
ধরুন, আপনি একটি ই-কমার্স অ্যাপ বানাচ্ছেন। সেখানে অর্ডারের ৩টি স্ট্যাটাস থাকতে পারে: 0 (Pending), 1 (Shipped), 2 (Delivered)।

সমস্যা: আপনি যদি কোডে বারবার 0, 1, 2 ব্যবহার করেন, তবে কয়েক মাস পর আপনি নিজেই ভুলে যাবেন 0 মানে কী ছিল। একে বলা হয় "Magic Numbers", যা কোডকে পচিয়ে ফেলে।

```ts
enum OrderStatus {
  Pending,   // ডিফল্টভাবে এর মান ০
  Shipped,   // মান ১
  Delivered  // মান ২
}

let myOrder = OrderStatus.Pending;

if (myOrder === OrderStatus.Pending) {
  console.log("আপনার অর্ডারটি প্রক্রিয়াধীন।");
}
```

2. Enum-এর প্রকারভেদ
ক) Numeric Enums (সংখ্যার এনাম)
উপরে যা দেখলেন তা-ই। আপনি চাইলে মান শুরু করতে পারেন যেকোনো সংখ্যা থেকে:

```ts
enum Direction {
  Up = 1,
  Down,    // অটোমেটিক ২ হয়ে যাবে
  Left,    // ৩
  Right    // ৪
}
```

খ) String Enums (লেখার এনাম)
এটি সবচেয়ে বেশি জনপ্রিয় এবং রিডাবল (Readable)। এতে ডিবাগিং করা সহজ হয়।

```ts
enum AppTheme {
  Light = "LIGHT_MODE",
  Dark = "DARK_MODE",
  System = "SYSTEM_DEFAULT"
}

console.log(AppTheme.Dark); // আউটপুট আসবে: "DARK_MODE"
```

3. Enum বনাম Union Types ("A" | "B")
আপনি হয়তো ভাবছেন, type Status = "Pending" | "Shipped" ব্যবহার করলেই তো হতো! পার্থক্যটা কোথায়?

- রানটাইম অস্তিত্ব: Enum(এটি জাভাস্ক্রিপ্টে একটি অবজেক্ট হিসেবে থাকে।) and Union Type(এটি কম্পাইল হওয়ার পর ভ্যানিশ হয়ে যায়।)
- ব্যবহার : Enum(আপনি OrderStatus.Pending লিখে কোড অটো-কমপ্লিট করতে পারেন।) and Union Type(আপনাকে সরাসরি স্ট্রিং লিখতে হয়।)

4. সাধারণ enum জাভাস্ক্রিপ্টে রূপান্তরের পর কিছুটা বাড়তি কোড তৈরি করে যা পারফরম্যান্সে প্রভাব ফেলতে পারে। আপনি যদি একদম ক্লিন কোড চান, তবে const enum ব্যবহার করুন।

```ts
const enum UserRole {
  Admin,
  Editor,
  User
}
// এটি কম্পাইল হওয়ার পর কোনো বাড়তি অবজেক্ট তৈরি করবে না, সরাসরি মান বসিয়ে দিবে।
```

## মডিউল: Export (Named vs Default)
জাভাস্ক্রিপ্ট এবং টাইপস্ক্রিপ্টে প্রতিটি ফাইলই একেকটি Module। একটি ফাইলের কোড অন্য ফাইলে নিতে হলে আপনাকে export ব্যবহার করতে হবে

- ক) Named Export (নাম ধরে পাঠানো)
একটি ফাইল থেকে আপনি অনেকগুলো জিনিস নাম দিয়ে পাঠাতে পারেন। আমদানির সময় ঠিক সেই নামটাই ব্যবহার করতে হবে।

```ts
// mathUtils.ts
export const add = (a: number, b: number) => a + b;
export const PI = 3.14;

// main.ts
import { add, PI } from "./mathUtils"; // নির্দিষ্ট নাম ধরে আনা
```

- খ) Default Export (এককভাবে পাঠানো)
একটি ফাইল থেকে শুধু একটি জিনিসই default হিসেবে পাঠানো যায়। আমদানির সময় আপনি যেকোনো নাম দিতে পারেন।

```ts
// Logger.ts
export default class Logger {
    log(msg: string) { console.log(msg); }
}

// main.ts
import MyLogger from "./Logger"; // এখানে Logger এর বদলে MyLogger নাম দিলেও কাজ করবে
```

## Namespace (নেমস্পেস): পুরানো কিন্তু দরকারি
মডিউল আসার আগে টাইপস্ক্রিপ্টে নেমস্পেস ব্যবহার করা হতো। এটি মূলত একটি গ্লোবাল অবজেক্টের ভেতরে আপনার কোডকে গ্রুপ করে রাখে যাতে নামের সংঘর্ষ (Naming conflict) না হয়।

```ts
namespace Validation {
    export const isString = (val: any) => typeof val === "string";
}

// ব্যবহার
Validation.isString("Hello");
```
**বর্তমানে: আধুনিক প্রজেক্টে নেমস্পেস খুব একটা ব্যবহৃত হয় না, Modules-ই এখন স্ট্যান্ডার্ড। তবে আপনি যদি কোনো লিগ্যাসি কোড বা গ্লোবাল লাইব্রেরি নিয়ে কাজ করেন, তবে এটি দেখতে পারেন।**

## Module Resolution (মডিউল রেজোলিউশন)
এটি হলো সেই প্রসেস যার মাধ্যমে টাইপস্ক্রিপ্ট কম্পাইলার খুঁজে বের করে যে আপনার import { x } from "module-name" আসলে কোন ফাইলে আছে।

টাইপস্ক্রিপ্টে মূলত দুটি স্ট্র্যাটেজি আছে:

- Classic: এটি পুরনো পদ্ধতি। এটি বর্তমান ফাইলের ডিরেক্টরিতে খুঁজে, না পেলে উপরের ডিরেক্টরিতে খুঁজতে থাকে।

- Node: এটি আধুনিক এবং সবচেয়ে বেশি ব্যবহৃত। এটি node_modules ফোল্ডার এবং package.json ফলো করে ফাইল খুঁজে বের করে।

**সিনিয়র টিপস: আপনার tsconfig.json ফাইলে "moduleResolution": "node" বা "bundler" সেট করা থাকে। যদি এটি ভুল থাকে, তবে আপনার কোড সব ঠিক থাকলেও টাইপস্ক্রিপ্ট "Module not found" এরর দিবে।**

**যখন import express from 'express' লেখেন, টাইপস্ক্রিপ্ট বা নোডজেএস (Node.js) তখন একটি নির্দিষ্ট নিয়ম মেনে ওই 'express' শব্দটিকে একটি ফিজিক্যাল ফাইলের সাথে মেলানোর চেষ্টা করে। একেই বলে Module Resolution।**


1. ১. সে কীভাবে খোঁজে? (The Lookup Process)
আপনি যখন শুধু নাম লেখেন (কোনো পাথ যেমন ./ বা ../ ছাড়া), তখন সে নিচের ধাপগুলো অনুসরণ করে:

- Core Modules: প্রথমে সে চেক করে এটি নোডের কোনো বিল্ট-ইন মডিউল কি না (যেমন: fs, path, http)।

- node_modules: যদি কোর মডিউল না হয়, তবে সে বর্তমান ফোল্ডারের node_modules চেক করে।

- Parent Folders: যদি সেখানে না পায়, তবে সে এক ধাপ উপরে উঠে তার node_modules চেক করে। এভাবে সে আপনার কম্পিউটারের Root ডিরেক্টরি পর্যন্ত খুঁজতে থাকে।

2. ফোল্ডারের ভেতরে সে কী দেখে?
ধরুন সে node_modules/express ফোল্ডারটি পেল। এখন সে কীভাবে বুঝবে কোন ফাইলটি মেইন ফাইল?

- package.json: সে প্রথমে এই ফাইলের ভেতরে ঢুকে "main" বা "types" ফিল্ডটি খোঁজে। যদি সেখানে লেখা থাকে "main": "index.js", সে ওই ফাইলটি লোড করে।

- index.ts / index.js: যদি package.json না থাকে, তবে সে ডিফল্টভাবে index ফাইলটি খোঁজে।

3. টাইপস্ক্রিপ্টের বিশেষত্ব: @types
এক্সপ্রেস (Express) মূলত জাভাস্ক্রিপ্টে লেখা। তাহলে টাইপস্ক্রিপ্ট কীভাবে এর টাইপগুলো বোঝে?

- টাইপস্ক্রিপ্ট যখন দেখে এক্সপ্রেসের নিজের ভেতরে কোনো টাইপ ডেফিনিশন নেই, তখন সে node_modules/@types/express ফোল্ডারটি খোঁজে।

- এজন্যই আমরা অনেক সময় npm install @types/express -D দিয়ে আলাদা করে টাইপ ইনস্টল করি।

4. রিলেটিভ পাথ (Relative Path) বনাম মডিউল
- import { myFunc } from './myFile': এখানে সে node_modules-এ খুঁজবে না। সে সরাসরি বর্তমান ফোল্ডারে myFile.ts বা myFile.js খুঁজবে।

- import axios from 'axios': এখানে সে সরাসরি node_modules-এ ঝাঁপ দেবে।

**Non-relative import ('express') -> node_modules-এ খোঁজে। ২. Relative import ('./express') -> লোকাল ফোল্ডারে খোঁজে। ৩. Resolution Strategy -> সাধারণত node স্ট্র্যাটেজি ব্যবহার করা হয়।**

