## অ্যারে (Array): "একই জাতের মেলা"
অ্যারে হলো এমন একটি লিস্ট যেখানে আপনি একই ধরনের অনেকগুলো ডাটা রাখতে পারেন। এর কোনো নির্দিষ্ট লিমিট নেই—আপনি যত খুশি ডাটা যোগ করতে পারেন।

```bash
let friends: string[] = ["Sakib", "Rakib", "Tamim"];
// অথবা
let salary: Array<number> = [25000, 30000, 45000];
```

## টাপল (Tuple): "ফিক্সড বা নির্দিষ্ট সেট"
এটিই হলো টাইপস্ক্রিপ্টের স্পেশাল ফিচার। টাপল হলো এমন এক ধরনের অ্যারে যেখানে:

1. ডাটা সংখ্যা ফিক্সড (কয়টা এলিমেন্ট থাকবে তা আগে থেকেই বলা থাকে)।
2. প্রতিটি পজিশনে কোন ধরনের ডাটা থাকবে তা নির্দিষ্ট।

```bash
let person: [number, string, boolean];

person = [1, "Anis", true]; // একদম সঠিক
// person = ["Anis", 1, true]; // ভুল! কারণ প্রথমে নাম্বার থাকার কথা ছিল।
```


**টাপল হলো আপনার মানিব্যাগের মতো। ধরুন আপনার মানিব্যাগে ৩টি পকেট আছে: প্রথম পকেটে শুধু 'টাকা' (Number), দ্বিতীয় পকেটে 'আইডি কার্ড' (String), আর তৃতীয় পকেটে 'বাসের টিকিট' (Boolean) থাকবে। আপনি চাইলে হুট করে পকেট বাড়াতে পারবেন না, আর এক পকেটের জিনিস অন্য পকেটে রাখতে পারবেন না।**

## ইন-ডেপথ মেকানিজম: কেন টাপল ব্যবহার করবেন?

একজন স্টাফ ইঞ্জিনিয়ার হিসেবে আমি তখনই টাপল ব্যবহার করি যখন আমি নিশ্চিত যে ডাটার স্ট্রাকচার বদলাবে না।

উদাহরণ: HTTP Status Code আপনি একটি API রেসপন্স পাঠাচ্ছেন যেখানে প্রথমটা হবে স্ট্যাটাস কোড (Number) আর দ্বিতীয়টা হবে মেসেজ (String)।

```bash
type Response = [number, string];

const success: Response = [200, "Success"];
const notFound: Response = [404, "Not Found"];
```

এখানে যদি ভুল করে কেউ ["Success", 200] লিখে ফেলে, তবে টাইপস্ক্রিপ্ট কম্পাইল করার আগেই এরর দেবে। জাভাস্ক্রিপ্টে এই ভুলটা ধরা খুব কঠিন হতো।

## একটি "বিপজ্জনক" বিষয় (Interview Secret)
টাপলের একটি সীমাবদ্ধতা আছে যা অনেক সিনিয়র ডেভেলপারও ভুল করেন। যদিও আমরা বলি টাপল "ফিক্সড", কিন্তু আপনি যদি .push() মেথড ব্যবহার করেন, তবে টাপলে নতুন ডাটা ঢুকে যায়!

```bash
let myTuple: [number, string] = [1, "Hello"];
myTuple.push(100); // টাইপস্ক্রিপ্ট এখানে এরর দেয় না! (এটি একটি ছোট ত্রুটি)
```
তাই টাপল ব্যবহারের সময় সরাসরি ইনডেক্স ধরে কাজ করা বা রিড-অনলি (readonly) করে রাখা ভালো।

## Object Types (অবজেক্টের কাঠামো)
জাভাস্ক্রিপ্টে অবজেক্ট যা খুশি হতে পারে। কিন্তু টাইপস্ক্রিপ্টে আমরা অবজেক্টের প্রতিটি "Key" বা প্রপার্টির টাইপ আগে থেকেই ঠিক করে দিই।

```bash
// একটি সাধারণ অবজেক্ট টাইপ ডিক্লেয়ারেশন
let employee: {
    readonly id: number; // এই আইডি পরিবর্তন করা যাবে না
    name: string;
    department?: string; // এখানে '?' মানে এটি অপশনাল (না দিলেও চলবে)
};

employee = {
    id: 101,
    name: "Rahat"
};
```
মেকানিজম: এখানে readonly ব্যবহার করায় আপনি চাইলে পরে employee.id = 200 করতে পারবেন না। এটি বড় অ্যাপ্লিকেশনে ডাটা ইনটিগ্রিটি বজায় রাখে।

## Type Aliases (টাইপ অ্যালিয়াস)
একই অবজেক্ট টাইপ যদি বারবার ব্যবহার করতে হয়, তবে সেটা বারবার লেখা বিরক্তিকর এবং কোড নোংরা করে। তাই আমরা একটি "নাম" বা ডাকনাম দিই। একেই বলে Type Alias।

```bash
// আমরা একটি 'User' টাইপ বানিয়ে নিলাম
type User = {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
};

// এখন এই 'User' নামটা যেকোনো জায়গায় ব্যবহার করা যাবে
const user1: User = {
    id: 1,
    name: "Karim",
    email: "karim@test.com",
    isActive: true
};
```

## Type Assertions (টাইপ জোরপূর্বক নির্ধারণ)
মাঝে মাঝে আপনি টাইপস্ক্রিপ্টের চেয়েও বেশি জানেন যে একটি ভেরিয়েবলে কী আছে। তখন আপনি টাইপস্ক্রিপ্টকে বলেন—"শোনো, আমি জানি আমি কী করছি, এটাকে এই টাইপ হিসেবে ধরো।" একেই বলে Type Assertion।

এটি সাধারণত as কীওয়ার্ড দিয়ে করা হয়।

বাস্তব উদাহরণ (DOM Manipulation):
ধরুন আপনি এইচটিএমএল থেকে একটি ইনপুট ফিল্ড ধরছেন। টাইপস্ক্রিপ্ট শুধু জানে এটা একটা Element, কিন্তু আপনি জানেন এটা একটা HTMLInputElement যার ভেতরে .value আছে।

```bash
const myInput = document.getElementById("search-box") as HTMLInputElement;

// এখন TS আমাকে '.value' ব্যবহার করতে দিবে
console.log(myInput.value);
```

unknown এর সাথে ব্যবহার:
আগের মেসেজে আমরা unknown দেখেছিলাম। সেটার সাথে Assertion খুব কাজে দেয়:
```bash
let someValue: unknown = "This is a string";

let strLength: number = (someValue as string).length;
// এখানে আমি TS কে জোর দিয়ে বললাম যে someValue আসলে একটি string।
```
**সতর্কতা: Assertion সাবধানে ব্যবহার করবেন। আপনি যদি ভুল করে একটি নাম্বারকে as string বলেন, তবে কম্পাইল টাইমে এরর আসবে না কিন্তু রানটাইমে আপনার অ্যাপ ক্রাশ করতে পারে।**

## ইন্টারফেস (interface): যখন আপনি অবজেক্টের কাঠামো বা ব্লুপ্রিন্ট চান
ইন্টারফেস মূলত অবজেক্ট এবং ক্লাসের আকার (Shape) নির্ধারণের জন্য তৈরি। এটি অনেকটা "চুক্তি" বা "Contract" এর মতো।

কখন ব্যবহার করবেন?
- Object/Class definition: যখন আপনি কোনো অবজেক্ট বা ক্লাসের প্রপার্টি ডিফাইন করতে চান।

- Declaration Merging: এটি ইন্টারফেসের একটি ইউনিক ক্ষমতা। একই নামে দুটি ইন্টারফেস লিখলে তারা অটোমেটিক মিলে যায় (Merge হয়)।

```ts
interface User {
  name: string;
}

interface User {
  age: number; // এটি আগের User ইন্টারফেসের সাথে যোগ হয়ে যাবে
}

const person: User = { name: "Abir", age: 25 };
```

## টাইপ অ্যালিয়াস (type): যখন আপনি ফ্লেক্সিবিলিটি চান
টাইপ অ্যালিয়াস যেকোনো কিছুর জন্য হতে পারে—অবজেক্ট, ইউনিয়ন, টাপল বা প্রিমিটিভ টাইপ।

কখন ব্যবহার করবেন?
- Union Types: যখন একটি ভেরিয়েবল একাধিক টাইপের হতে পারে (যেমন: string | number)। এটি ইন্টারফেস দিয়ে সম্ভব নয়।

- Tuples: টাপল ডিফাইন করার জন্য টাইপই সেরা।

- Computed Properties: কমপ্লেক্স কোনো টাইপ লজিক তৈরি করতে হলে।

```ts
type ID = string | number; // Union type
type Point = [number, number]; // Tuple
```

টাইপস্ক্রিপ্টে (TypeScript) অবজেক্ট বা ডেটার আকার নির্ধারণ করতে আমরা এই দুটি পদ্ধতি ব্যবহার করি। তাদের পার্থক্য নিচে দেওয়া হলো:

| বৈশিষ্ট্য (Feature) | Interface (ইন্টারফেস) | Type Alias (টাইপ এলিয়াস) |
| :--- | :--- | :--- |
| **অবজেক্ট ও ক্লাস** (Objects & Classes) | খুব ভালোভাবে হ্যান্ডেল করে। | হ্যান্ডেল করতে পারে। |
| **এক্সটেনশন** (Inheritance) | `extends` কীওয়ার্ড ব্যবহার করে। | `&` (Intersection) ব্যবহার করে। |
| **মার্জিং** (Merging) | একই নামে একাধিক থাকলে অটো-মার্জ হয়। | একই নামে দুটি থাকলে এরর (Error) দেয়। |
| **ইউনিয়ন টাইপ** (Union Types) | সাপোর্ট করে না। | দারুণভাবে সাপোর্ট করে। |

## রিয়েল-ওয়ার্ল্ড সিনারিও (Real-world Scenarios)
**সিনারিও ১: আপনি একটি লাইব্রেরি বানাচ্ছেন (Use Interface)**
আপনি যদি এমন একটি প্যাকেজ বানান যা অন্য ডেভেলপাররা ব্যবহার করবে, তবে interface ব্যবহার করা ভালো। কারণ ইউজার চাইলে আপনার ইন্টারফেসটি "Declaration Merging" এর মাধ্যমে এক্সটেন্ড করতে পারবে।

**সিনারিও ২: API রেসপন্স হ্যান্ডেল করা (Use Type)**
API থেকে আসা ডাটা প্রায়ই ডাইনামিক হয়। সেখানে ইউনিয়ন বা ইন্টারসেকশন দরকার পড়ে।

```ts
type SuccessResponse = { data: object; status: 200 };
type ErrorResponse = { error: string; status: 404 };

type ApiResponse = SuccessResponse | ErrorResponse; // ইন্টারফেস দিয়ে এটা করা কঠিন
```

**সিনারিও ৩: রিঅ্যাক্ট প্রপস (React Props)**
সাধারণত রিঅ্যাক্ট কম্পোনেন্টের প্রপস ডিফাইন করার জন্য ডেভেলপাররা interface পছন্দ করেন কারণ এর এরর মেসেজগুলো বেশি পরিষ্কার হয়। তবে যদি আপনার প্রপসে ইউনিয়ন টাইপ লাগে, তবে type ব্যবহার করতেই হবে।

**১. ডিফল্ট হিসেবে interface ব্যবহার করুন—যতক্ষণ না আপনার ইউনিয়ন বা টাপল টাইপের প্রয়োজন পড়ছে। এটি কোডকে বেশি অবজেক্ট-ওরিয়েন্টেড রাখে। ২. পারফরম্যান্স: টাইপস্ক্রিপ্ট ইঞ্জিন ইন্টারফেসের ইনহেরিটেন্স দ্রুত প্রসেস করতে পারে কারণ এটি মেমোরিতে টাইপগুলো ক্যাশ (Cache) করে রাখে, যেখানে type এর ইন্টারসেকশন (&) প্রতিবার নতুন করে ক্যালকুলেট করতে হয়।**

## extends (Interface এর ক্ষমতা)
ইন্টারফেস যখন অন্য একটি ইন্টারফেসের বৈশিষ্ট্য ধার করে, তখন আমরা extends ব্যবহার করি। এটি দেখতে অনেকটা জাভা বা সি-শার্পের ক্লাসিক ইনহেরিটেন্সের মতো।


```ts
interface Animal {
    name: string;
}

interface Dog extends Animal {
    breed: string;
}

const myDog: Dog = {
    name: "Rex",
    breed: "German Shepherd"
};
```

ইন্টারনাল মেকানিজম:

- Hierarchy: এটি একটি হায়ারার্কি বা বংশপরম্পরা তৈরি করে।

- Conflict Checking: যদি Dog-এ এমন কোনো প্রপার্টি থাকে যা Animal-এর সাথে সাংঘর্ষিক (যেমন Animal-এ name হলো string আর Dog-এ আপনি দিতে চাইলেন number), তবে টাইপস্ক্রিপ্ট সাথে সাথে আপনাকে বড় একটি এরর দেবে।

- Performance: ইন্টারফেস যখন extends হয়, তখন টাইপস্ক্রিপ্ট ইঞ্জিন এটি মেমোরিতে ক্যাশ (Cache) করে রাখে। ফলে বড় প্রজেক্টে এটি দ্রুত কাজ করে।

## Intersection (&) (Type Alias এর ক্ষমতা)
ইন্টারসেকশন মানে হলো দুই বা ততোধিক টাইপকে একসাথে জোড়া দিয়ে একটি নতুন টাইপ বানানো। এটি অনেকটা জগাখিচুড়ি পাকানোর মতো—সবকিছু এক জায়গায় চলে আসবে।

```ts
type Flyable = {
    canFly: boolean;
};

type Swimmable = {
    canSwim: boolean;
};

type SuperDuck = Flyable & Swimmable;

const duck: SuperDuck = {
    canFly: true,
    canSwim: true
};
```

ইন্টারনাল মেকানিজম:

- Recursive Merging: এটি কোনো বংশপরম্পরা মানে না, শুধু প্রপার্টিগুলো একটার সাথে আরেকটা মিলিয়ে দেয়।

- Never Type Conflict: যদি দুটি টাইপে একই নামের প্রপার্টি থাকে কিন্তু তাদের টাইপ আলাদা হয় (যেমন একটিতে id: string অন্যটিতে id: number), তবে ইন্টারসেকশন করার পর সেটি never টাইপ হয়ে যায়। কারণ কোনো কিছু একই সাথে স্ট্রিং এবং নাম্বার হতে পারে না। ফলে আপনার অবজেক্টটি ব্যবহার অনুপযোগী হয়ে পড়ে।

## রিয়েল-ওয়ার্ল্ড সিনারিও (কখন কোনটি?)
কখন extends ব্যবহার করবেন?
যখন আপনি একটি পরিষ্কার কাঠামো বা আর্কিটেকচার তৈরি করছেন। যেমন একটি বেস User থেকে Admin এবং Customer তৈরি করা। এতে কোড রিডাবিলিটি ভালো থাকে।

কখন & (Intersection) ব্যবহার করবেন?
যখন আপনার হুট করে দুটি আলাদা জিনিসের বৈশিষ্ট্য এক জায়গায় দরকার। ধরুন একটি Log টাইপ আর একটি User টাইপ আছে, আপনি এখন একটি ফাংশনে এই দুইটার কম্বিনেশন চাচ্ছেন। এছাড়া Union Types-এর সাথে কাজ করতে হলে ইন্টারসেকশন ছাড়া উপায় নেই।

**আপনি যদি পারফরম্যান্স এবং ক্লিন এরর মেসেজ চান, তবে সবসময় interface এবং extends আগে ব্যবহার করার চেষ্টা করবেন। আর যদি আপনি অ্যাডভান্সড কোনো টাইপ ম্যানিপুলেশন করেন (যেখানে ইউনিয়ন বা প্রিমিটিভ টাইপ আছে), তখন & ব্যবহার করবেন।**

