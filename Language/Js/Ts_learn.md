## JavaScript: ইঞ্জিন রুমের ভেতরে কী ঘটে?

জাভাস্ক্রিপ্ট মূলত একটি Single-threaded, interpreted (or JIT compiled) ভাষা। এটি রান করার জন্য ভি-৮ (V8) ইঞ্জিনের মতো (Chrome/Node.js-এ থাকে) শক্তিশালী মেকানিজম ব্যবহার করে।


## V8 ইঞ্জিন এবং পার্সিং
যখন আপনি JS কোড রান করেন, ইঞ্জিন প্রথমে এটিকে Abstract Syntax Tree (AST)-এ রূপান্তর করে।

- Parser: আপনার কোড পড়ে টোকেন তৈরি করে।
- Ignition Interpreter: এটি দ্রুত কোড রান করার জন্য বাইটকোড (Bytecode) তৈরি করে।
- TurboFan (JIT Compiler): যদি কোনো ফাংশন বারবার কল হয় (Hot code), তবে এটি সেই কোডকে সরাসরি 'Machine Code'-এ কনভার্ট করে ফেলে যাতে পারফরম্যান্স সর্বোচ্চ হয়।

## Call Stack এবং Event Loop
জাভাস্ক্রিপ্ট একবারে একটি কাজ করতে পারে। কিন্তু আমরা যখন API কল করি বা টাইমার সেট করি, তখন কীভাবে কাজ করে? এখানেই আসে Event Loop।

- Call Stack: যেখানে ফাংশনগুলো সিরিয়ালি জমা হয় এবং এক্সিকিউট হয় (LIFO - Last In, First Out)।
- Web APIs: ব্রাউজারের দেওয়া সুবিধা (যেমন: setTimeout, fetch) যা ব্যাকগ্রাউন্ডে কাজ করে।
- Task Queue/Microtask Queue: ব্যাকগ্রাউন্ডের কাজ শেষ হলে কলব্যাকগুলো এখানে অপেক্ষা করে।
- Event Loop: এটি সারাক্ষণ চেক করে—যদি স্ট্যাক খালি থাকে, তবে কিউ থেকে কাজ নিয়ে স্ট্যাকে পাঠায়।

## TypeScript: এটি আসলে কী এবং কেন?
টাইপস্ক্রিপ্ট কোনো আলাদা ভাষা নয়, এটি জাভাস্ক্রিপ্টের একটি Syntactic Sugar বা Superset। ব্রাউজার টাইপস্ক্রিপ্ট বোঝে না।

1.  ট্রান্সপাইলেশন (Transpilation)
TS কোডকে প্রথমে TSC (TypeScript Compiler) দিয়ে JS-এ কনভার্ট করতে হয়। একে বলে ট্রান্সপাইলেশন।

- Type Erasure: কম্পাইল করার পর সব টাইপ ডেফিনিশন (interface, type) মুছে যায়। আউটপুট হিসেবে আপনি পান ক্লিন জাভাস্ক্রিপ্ট।

2. Static vs Dynamic Typing
- JS (Dynamic): রানটাইমে ভেরিয়েবল চেক করে। ফলে অ্যাপ চলাকালীন এরর হওয়ার সম্ভাবনা থাকে।
- TS (Static): কোড লেখার সময় (Compile-time) এরর ধরে ফেলে। স্টাফ ইঞ্জিনিয়ার হিসেবে আমরা এটি ব্যবহার করি মূলত বড় টিমে কোডের রিডাবিলিটি এবং মেইনটেনেবিলিটি নিশ্চিত করতে।

## মেমোরি ম্যানেজমেন্ট (The Garbage Collector)
জাভাস্ক্রিপ্ট অটোমেটিক মেমোরি ম্যানেজ করে। যখন কোনো অবজেক্টের আর কোনো রেফারেন্স থাকে না, তখন Mark-and-Sweep অ্যালগরিদম ব্যবহার করে মেমোরি খালি করা হয়।

- Marking: রুট (Global object) থেকে শুরু করে কোন কোন অবজেক্ট রিচেবল (Reachable) তা মার্ক করে।
- Sweeping: যেগুলো মার্ক করা নেই, সেগুলো মেমোরি থেকে মুছে দেয়।

## Staff Engineer Perspective: কেন এগুলো জানা জরুরি?
**১.** Memory Leaks: আপনি যদি গ্লোবাল ভেরিয়েবল বা ইভেন্ট লিসেনার রিমুভ না করেন, তবে গারবেজ কালেক্টর তা মুছতে পারবে না, ফলে অ্যাপ স্লো হয়ে যাবে।
**২.** Asynchronous Bottlenecks: ইভেন্ট লুপ কীভাবে কাজ করে না জানলে আপনি 'Callback Hell' বা 'Main thread blocking'-এর মতো সমস্যায় পড়বেন।
 **৩.** Type Safety: টাইপস্ক্রিপ্ট ব্যবহার করলে প্রোডাকশনে রানটাইম এরর প্রায় ৯০% কমিয়ে আনা সম্ভব।


## Asynchronous JavaScript: Promises & Async-Await (The Underworld)
আমরা জানি JS সিঙ্গেল-থ্রেডেড, কিন্তু এটি কীভাবে একসাথে অনেক কাজ (যেমন API কল) সামলায়? এর আসল নায়ক হলো Microtask Queue।

## Promises কীভাবে কাজ করে?
যখন আপনি একটি Promise তৈরি করেন, এটি তিনটি স্টেটের যেকোনো একটিতে থাকে: Pending, Fulfilled, অথবা Rejected। কিন্তু মজার ব্যাপার হলো এর Execution Priority।

1. Macro-tasks: setTimeout, setInterval, I/O অপারেশন।
2. Micro-tasks: Promise.then, catch, finally, process.nextTick (Node.js)।

Event Loop-এর নিয়ম: ইভেন্ট লুপ যখনই একটি Macro-task শেষ করে, সে সাথে সাথে দেখে Microtask Queue-তে কিছু আছে কি না। যতক্ষণ মাইক্রোটাস্ক কিউ খালি না হবে, সে পরবর্তী ম্যাক্রোটাস্ক (যেমন অন্য একটি setTimeout) ধরবে না।

## Async-Await: এটা কি শুধুই চিনি (Syntactic Sugar)?
হ্যাঁ! Async-Await আসলে Generators এবং Promises এর একটি কম্বিনেশন।

- যখন আপনি await লেখেন, ইঞ্জিন আসলে ওই ফাংশনের এক্সিকিউশনকে "পজ" (Pause) করে দেয়।
- এটি মূল থ্রেডকে ব্লক করে না, বরং ফাংশনটিকে ব্যাকগ্রাউন্ডে পাঠিয়ে দেয়। যখন প্রমিসটি রিজলভ হয়, তখন এটি আবার কল স্ট্যাকে ফিরে আসে।

## Prototypal Inheritance: আসল মেকানিজম
অধিকাংশ ল্যাঙ্গুয়েজ (Java/C++) এ 'Class-based' ইনহেরিটেন্স থাকে, কিন্তু জাভাস্ক্রিপ্টে ক্লাস আসলে একটি মুখোশ। ভেতরে যা চলে তাকে বলে Prototypal Chain।

**এটি কীভাবে কাজ করে?**
জাভাস্ক্রিপ্টে প্রতিটি অবজেক্টের একটি গোপন লিংক থাকে তার প্যারেন্ট অবজেক্টের সাথে, যাকে আমরা বলি [[Prototype]] (কোডে এটি __proto__ হিসেবে দেখা যায়)।

```bash
const animal = { eats: true };
const rabbit = { jumps: true };

rabbit.__proto__ = animal; // rabbit এখন animal কে ইনহেরিট করছে
```

## The Search Algorithm: যখন আপনি rabbit.eats কল করেন, ইঞ্জিন নিচের কাজগুলো করে:
1. প্রথমে rabbit অবজেক্টের ভেতরে eats প্রপার্টি খোঁজে।
2. না পেলে সে তার __proto__ (অর্থাৎ animal) এর কাছে যায়।
3. সেখানেও না পেলে সে animal.__proto__ (অর্থাৎ Object.prototype) এর কাছে যায়।
4. একেবারে শেষে null পর্যন্ত খোঁজে। একেই বলে Prototype Chain।

## স্টাফ ইঞ্জিনিয়ার টিপস:
আমরা এখন ক্লাসের ভেতর super() কল করি বা extends ব্যবহার করি, কিন্তু ব্রাউজার এখনো পর্দার আড়ালে এই চেইনটাই মেইনটেইন করে। কেন এটি জানা জরুরি? কারণ মেমোরি সেভ করার জন্য। আপনি যদি কোনো মেথডকে প্রোটোটাইপে রাখেন, তবে ওই ক্লাসের ১০০০টি ইনস্ট্যান্স তৈরি করলেও মেথডটি মেমোরিতে মাত্র একবারই থাকবে।

## Performance & Memory Perspective
একজন সিনিয়র ইঞ্জিনিয়ার হিসেবে আপনাকে এই দুটি বিষয়ে সতর্ক থাকতে হবে:

- Promise Starvation: আপনি যদি লুপের ভেতর প্রচুর মাইক্রোটাস্ক (Promises) তৈরি করেন, তবে ইভেন্ট লুপ কখনোই ম্যাক্রোটাস্ক (যেমন UI রেন্ডারিং বা ক্লিক ইভেন্ট) পর্যন্ত পৌঁছাতে পারবে না। ফলে আপনার ব্রাউজার ট্যাব ফ্রিজ হয়ে যাবে।

- Shadowing: প্রোটোটাইপ চেইনে যদি অনেক গভীর লেভেলে ডাটা থাকে, তবে সেটি খুঁজতে ইঞ্জিনের সময় বেশি লাগে। তাই ইনহেরিটেন্স চেইন খুব বেশি লম্বা করা উচিত নয়।
