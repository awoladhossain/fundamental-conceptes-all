## JavaScript: ইঞ্জিন রুমের ভেতরে কী ঘটে?

জাভাস্ক্রিপ্ট মূলত একটি Single-threaded, interpreted (or JIT compiled) ভাষা। এটি রান করার জন্য ভি-৮ (V8) ইঞ্জিনের মতো (Chrome/Node.js-এ থাকে) শক্তিশালী মেকানিজম ব্যবহার করে।


## V8 ইঞ্জিন এবং পার্সিং
যখন আপনি JS কোড রান করেন, ইঞ্জিন প্রথমে এটিকে Abstract Syntax Tree (AST)-এ রূপান্তর করে।

- Parser: আপনার কোড পড়ে টোকেন তৈরি করে।
- Ignition Interpreter: এটি দ্রুত কোড রান করার জন্য বাইটকোড (Bytecode) তৈরি করে।
- TurboFan (JIT Compiler): যদি কোনো ফাংশন বারবার কল হয় (Hot code), তবে এটি সেই কোডকে সরাসরি 'Machine Code'-এ কনভার্ট করে ফেলে যাতে পারফরম্যান্স সর্বোচ্চ হয়।

## Call Stack এবং Event Loop
জাভাস্ক্রিপ্ট একবারে একটি কাজ করতে পারে। কিন্তু আমরা যখন API কল করি বা টাইমার সেট করি, তখন কীভাবে কাজ করে? এখানেই আসে Event Loop।

- Call Stack: যেখানে ফাংশনগুলো সিরিয়ালি জমা হয় এবং এক্সিকিউট হয় (LIFO - Last In, First Out)।
- Web APIs: ব্রাউজারের দেওয়া সুবিধা (যেমন: setTimeout, fetch) যা ব্যাকগ্রাউন্ডে কাজ করে।
- Task Queue/Microtask Queue: ব্যাকগ্রাউন্ডের কাজ শেষ হলে কলব্যাকগুলো এখানে অপেক্ষা করে।
- Event Loop: এটি সারাক্ষণ চেক করে—যদি স্ট্যাক খালি থাকে, তবে কিউ থেকে কাজ নিয়ে স্ট্যাকে পাঠায়।

## TypeScript: এটি আসলে কী এবং কেন?
টাইপস্ক্রিপ্ট কোনো আলাদা ভাষা নয়, এটি জাভাস্ক্রিপ্টের একটি Syntactic Sugar বা Superset। ব্রাউজার টাইপস্ক্রিপ্ট বোঝে না।

1.  ট্রান্সপাইলেশন (Transpilation)
TS কোডকে প্রথমে TSC (TypeScript Compiler) দিয়ে JS-এ কনভার্ট করতে হয়। একে বলে ট্রান্সপাইলেশন।

- Type Erasure: কম্পাইল করার পর সব টাইপ ডেফিনিশন (interface, type) মুছে যায়। আউটপুট হিসেবে আপনি পান ক্লিন জাভাস্ক্রিপ্ট।

2. Static vs Dynamic Typing
- JS (Dynamic): রানটাইমে ভেরিয়েবল চেক করে। ফলে অ্যাপ চলাকালীন এরর হওয়ার সম্ভাবনা থাকে।
- TS (Static): কোড লেখার সময় (Compile-time) এরর ধরে ফেলে। স্টাফ ইঞ্জিনিয়ার হিসেবে আমরা এটি ব্যবহার করি মূলত বড় টিমে কোডের রিডাবিলিটি এবং মেইনটেনেবিলিটি নিশ্চিত করতে।

## মেমোরি ম্যানেজমেন্ট (The Garbage Collector)
জাভাস্ক্রিপ্ট অটোমেটিক মেমোরি ম্যানেজ করে। যখন কোনো অবজেক্টের আর কোনো রেফারেন্স থাকে না, তখন Mark-and-Sweep অ্যালগরিদম ব্যবহার করে মেমোরি খালি করা হয়।

- Marking: রুট (Global object) থেকে শুরু করে কোন কোন অবজেক্ট রিচেবল (Reachable) তা মার্ক করে।
- Sweeping: যেগুলো মার্ক করা নেই, সেগুলো মেমোরি থেকে মুছে দেয়।

## Staff Engineer Perspective: কেন এগুলো জানা জরুরি?
**১.** Memory Leaks: আপনি যদি গ্লোবাল ভেরিয়েবল বা ইভেন্ট লিসেনার রিমুভ না করেন, তবে গারবেজ কালেক্টর তা মুছতে পারবে না, ফলে অ্যাপ স্লো হয়ে যাবে।
**২.** Asynchronous Bottlenecks: ইভেন্ট লুপ কীভাবে কাজ করে না জানলে আপনি 'Callback Hell' বা 'Main thread blocking'-এর মতো সমস্যায় পড়বেন।
 **৩.** Type Safety: টাইপস্ক্রিপ্ট ব্যবহার করলে প্রোডাকশনে রানটাইম এরর প্রায় ৯০% কমিয়ে আনা সম্ভব।


## Asynchronous JavaScript: Promises & Async-Await (The Underworld)
আমরা জানি JS সিঙ্গেল-থ্রেডেড, কিন্তু এটি কীভাবে একসাথে অনেক কাজ (যেমন API কল) সামলায়? এর আসল নায়ক হলো Microtask Queue।

## Promises কীভাবে কাজ করে?
যখন আপনি একটি Promise তৈরি করেন, এটি তিনটি স্টেটের যেকোনো একটিতে থাকে: Pending, Fulfilled, অথবা Rejected। কিন্তু মজার ব্যাপার হলো এর Execution Priority।

1. Macro-tasks: setTimeout, setInterval, I/O অপারেশন।
2. Micro-tasks: Promise.then, catch, finally, process.nextTick (Node.js)।

Event Loop-এর নিয়ম: ইভেন্ট লুপ যখনই একটি Macro-task শেষ করে, সে সাথে সাথে দেখে Microtask Queue-তে কিছু আছে কি না। যতক্ষণ মাইক্রোটাস্ক কিউ খালি না হবে, সে পরবর্তী ম্যাক্রোটাস্ক (যেমন অন্য একটি setTimeout) ধরবে না।
